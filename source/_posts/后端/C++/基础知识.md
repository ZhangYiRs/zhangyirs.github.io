---
title: 基础知识
date: 2024-03-25 15:19:40
tags: C++
categories: [C++]
---
## 安装

## 基础知识点

### 基础类型

1. 整型：short、int、long、long long
2. 浮点型：float、double
3. 字符型：char
4. 字符串：string
5. 布尔类型：bool

sizeof关键字可统计数据类型所占用的内存大小

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
	//C风格字符串
	char cStr[] = "hello c str";
	cout << cStr << endl;

	//C++风格字符串
	string cppStr = "hello cpp str";
	cout << cppStr << endl;
	return 0;
}
```

使用C++风格字符串时，需包含头文件#include <string>

### 运算

只有整数能进行取模运算

### 函数

> 函数声明（函数头）：`return_type function_name( parameter list );`
> 函数定义：

```c++
return_type function_name( parameter list ){
   body of the function
}
```

> 函数下方只能调用上方的，如果想任意调用，需要在文件开头声明函数头。
> 函数声明可以有多次，函数定义只能有一次。

函数分文件编写 `#include "文件名.h"`

1. 创建后缀名为.h的头文件
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

### 指针

> 定义指针：数据类型 * 指针变量名
> 指针变量复制：p = &a; 指针p只想变量a的地址
> 解引用（使用指针）： * 指针变量
> 空指针：int* p = NULL; 不能解引用
> 野指针：int* p = (int*)0x1100; 不能解引用


```c++
// 常量指针，不能改解引用中的内容
const int* p = & a;
p = &b;
// 指针常量，不能改指针指向
int* const p2 = &a;
*p2 = b;
// 都不能修改
const int* const p3 = &a;
```

### 引用

引用的本质是常量函数

`int &a`


### 访问权限

- public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；
- protected：可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问；
- private：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象、访问。

```c++
class Base {
public:
    // 公有成员
protected:
    // 受保护成员
private:
    // 私有成员
}
```

### 构造函数和析构函数

析构函数语法： ~类名(){}
1.析构函数，没有返回值也不写void
2.函数名称与类名相同,在名称前加上符号 ~
3.析构函数不可以有参数，因此不可以发生重载
4.程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次

```c++
class Person{
public:
	Person(){
		cout << "调用构造函数" << endl;
	}
	//对象销毁前，自动调用
	~Person(){
		cout << "析构函数的调用" << endl;
	}
}
```

### 在类外定义成员函数、inline成员函数

在类外定义成员函数
成员函数可以在类体中直接定义。也可以在类体中只写成员函数的声明，而在类的外面进行函数定义。如：

```c++
class Student
{
public :
    void display( ); //公用成员函数原型声明  
private :
    int num;
    string name;
    char sex;
    //以上3行是私有数据成员
};
void Student::display( )//在类外定义display类函数  
{
    cout<<"num:"<<num<<endl;
    cout<<"name:"<<name<<endl;
    cout<<"sex:"<<sex<<endl;
}
Student stud1,stud2; //定义两个类对象
```

注意：在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。但成员函数在类外定义时，必须在函数名前面加上类名，予以限定(qualifed)，” :: “是作用域限定符(field qualifier)或称作用域运算符，用它声明函数是属于哪个类的。:: 可以不跟类名，表示全局数据或全局函数（即非成员函数）。

```c++
int month;//全局变量
int day;
int year;
void Set(int m,int d,int y)
{
    ::year=y; //给全局变量赋值，此处可省略
    ::day=d;
    ::month=m;
}

Class Tdate
{
    public:
        void Set(int m,int d,int y) //成员函数
        {
            ::Set(m,d,y); //非成员函数
        }
    private:
        int month;
        int day;
        int year;
}
```

类函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前，否则编译时会出错。虽然函数在类的外部定义，但在调用成员函数时会根据在类中声明的函数原型找到函数的定义（函数代码），从而执行该函数。在类的内部对成员函数作声明，而在类体外定义成员函数，这是程序设计的一种良好习惯。如果一个函数，其函数体只有2-3行，一般可在声明类时在类体中定义。多于3行的函数，一般在类体内声明，在类外定义。

#### inline 成员函数

在类体中定义的成员函数的规模一般都很小，而系统调用函数的过程所花费的时间开销相对是比较大的。调用一个函数的时间开销远远大于小规模函数体中全部语句的执行时间。为了减少时间开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++系统会自动将它们作为内置(inline)函数来处理。也就是说，在程序调用这些成员函数时，并不是真正地执行函数的调用过程(如保留返回地址等处理)，而是把函数代码嵌入程序的调用点。这样可以大大减少调用成员函数的时间开销。C++要求对一般的内置函数要用关键字inline声明，但对类内定义的成员函数，可以省略inline，因为这些成员函数已被隐含地指定为内置函数。如：

```c++ 
class Student
{
public :
    void display()
    {
        cout<<"num:"<<num<<endl;cout<<"name:"
        <<name<<endl;cout<<"sex:"<<sex<<endl;
    }
private :
    int num;
    string name;
    char sex;
};
```

其中第4行 void display( )也可以写成 inline void display()，将display函数显式地声明为内置函数。以上两种写法是等效的。对在类体内定义的函数，一般都省写inline。应该注意的是，如果成员函数不在类体内定义，而在类体外定义，系统并不把它默认为内置(inline)函数，调用这些成员函数的过程和调用一般函数的过程是相同的。如果想将这些成员函数指定为内置函数，应当用inline作显式声明。如：

```c++
class Student
{
    public : inline void display( );//声明此成员函数为内置函数
    private :
    int num;
    string name;
    char sex;
};

inline void Student::display( ) // 在类外定义display函数为内置函数
{
    cout<<"num:"<<num<<endl;cout<<"name:"<<name<<endl;cout<<"sex:"<<sex<<endl;
}
```

值得注意的是，如果在类体外定义inline函数，则必须将类定义和成员函数的定义都放在同一个头文件中(或者写在同一个源文件中)，否则编译时无法进行置换(将函数代码的拷贝嵌入到函数调用点)。但是这样做，不利于类的接口与类的实现分离，不利于信息隐蔽。虽然程序的执行效率提高了，但从软件工程质量的角度来看，这样做并不是好的办法。只有在类外定义的成员函数规模很小而调用频率较高时，才将此成员函数指定为内置函数。

### 友元

> 友元的关键字为friend

友元三种实现

- 全局函数做友元
- 类做友元
- 成员函数做友元

```c++
#include <iostream>
#include <string>

using namespace std;

// 房屋类
class Building
{
	// 告诉编译器 laoWang全局函数是 Building类  的好朋友，可以访问Building对象的私有成员
	friend void laoWang1(Building *building);
	friend void laoWang2(Building &building);
	friend void laoWang3(Building building);

public:

	Building()
	{
		m_SittingRoom = "客厅";
		m_BedRoom = "卧室";
	}
	
	string m_SittingRoom;	// 客厅

private:

	string m_BedRoom;		// 卧室
};



//全局函数
void laoWang1(Building *building)
{
	cout << "隔壁老王 全局函数 正在访问：（地址传递） " << building->m_SittingRoom << endl;

	cout << "隔壁老王 全局函数 正在访问：（地址传递） " << building->m_BedRoom << endl;
}

void laoWang2(Building &building)
{
	cout << "隔壁老王 全局函数 正在访问：（引用传递） " << building.m_SittingRoom << endl;

	cout << "隔壁老王 全局函数 正在访问：（引用传递） " << building.m_BedRoom << endl;
}

void laoWang3(Building building)
{
	cout << "隔壁老王 全局函数 正在访问：（ 值传递 ） " << building.m_SittingRoom << endl;

	cout << "隔壁老王 全局函数 正在访问：（ 值传递 ） " << building.m_BedRoom << endl;
}

void test()
{
	Building building;
	laoWang1(&building);
	laoWang2(building);
	laoWang3(building);
}


int main()
{
	test();
}

```


### 运算符重载

> 运算符重载就是赋予运算符新的含义（新功能），其本质是一个函数。
> C++预定义中的运算符的操作对象只局限于基本的内置数据类型，但是对于我们自定义的类型是没办法操作的，此时就需要重载运算符来实现。
> 可以作为成员函数重载也可以作为全局函数重载

运算符函数定义的一般格式如下：

```c++
<返回类型说明符> operator <运算符符号>(<参数表>)

{

     <函数体>

}
```

#### 运算符重载时要遵循以下规则

> 1. 除了类属关系运算符"."、成员指针运算符".*"、作用域运算符"::"、sizeof运算符和三目运算符"?:"以外，其他运算符都可以重载。
> 2. 重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符
> 3. 运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。
> 4. 重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。
> 5. 运算符重载不能改变该运算符用于内部类型对象的含义。它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用时。
> 6. 运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似。
> 7. 一个运算符被重载后，原有意思没有失去，只是定义了相对一特定类的一个新运算符。


```c++
#include <iostream>

using namespace std;

 

class Complex{

public:

    Complex(int a = 0, int b = 0){
        this->a = a;
        this->b = b;
    }

	// 作为成员函数重载Complex的+法运算
	Complex operator+(Complex &c1){
		Complex tmp(c1.a + this.a, c1.b + this.b);
		return tmp;
	}

    void print(){
        cout << "a:b => " << a << ":" << b << endl;
    }

public:
    int a;
    int b;

};

 
// 作为全局函数重载Complex的+法运算
Complex operator+(Complex &c1, Complex &c2){
    Complex tmp(c1.a + c2.a, c1.b + c2.b);
    return tmp;
}

 
void main(){
    int a = 0, b = 0;
    int c = a + b; //1 基础类型编译器知道怎么做
    //用户定义复杂类型需要用户重载运算符编译才知道怎么做
    Complex c1(1, 2), c2(3, 4);
    Complex c3 = c1 + c2;
    c3.print();
    system("pause");
    return;
}
```

自增运算符重载时需要注意，第二个参数只能是常量引用或者为浅拷贝对象，否则<<会报错

```c++
#include <iostream>

using namespace std;

class MyInt {
    friend ostream &operator<<(ostream &out,const MyInt &a);
public:
    // 前置++
    MyInt &operator++() {
        ++a;
        return *this;
    }

    // 后置++，只能返回值不能返回对象，因为当前对象自增后已经变更，只能返回历史的值
    MyInt operator++(int) {
        MyInt temp = *this;
        ++*this;
        return temp;
    }

private:
    int a=1;
};

// 重载<<
ostream &operator<<(ostream &out,const MyInt &a) {
    out << "a:" << a.a;
    return out;
}

void test() {

    MyInt test2;
    cout << test2++ << endl;
    cout << ++test2++ << endl;
}


class MyInt2 {
    friend ostream &operator<<(ostream &out, MyInt2 a) ;
public:
    // 前置++
    MyInt2 &operator++() {
        ++a;
        return *this;
    }

    // 后置++，只能返回值不能返回对象，因为当前对象自增后已经变更，只能返回历史的值
    MyInt2 operator++(int) {
        MyInt2 temp = *this;
        ++*this;
        return temp;
    }

private:
    int a=1;
};

// 重载<<
ostream &operator<<(ostream &out, MyInt2 a) {
    out << "a:" << a.a;
    return out;
}

void test2() {

    MyInt2 test2;
    cout << test2++ << endl;
    cout << test2 << endl;
}

int main() {
    test();
    test2();

    return 0;
}
```