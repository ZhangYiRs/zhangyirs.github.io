---
title: 动态指针
date: 2024-10-07 15:19:40
tags: C++
categories: [C++]
---
## 动态指针

### unique_ptr

#### 示例1

> 在 C++ 中，std::unique_ptr 是一种智能指针，用于管理动态分配的对象。下面是一个简单的例子，展示如何在头文件和源文件中使用 std::unique_ptr。

```c++
头文件 (example.h)

#ifndef EXAMPLE_H
#define EXAMPLE_H

#include <memory>
#include <iostream>

class MyClass {
public:
    MyClass();
    ~MyClass();

    void display();

private:
    struct Impl; // 前向声明
    std::unique_ptr<Impl> impl; // 使用 unique_ptr
};

#endif // EXAMPLE_H
源文件 (example.cpp)
#include "example.h"

struct MyClass::Impl {
    int value;
    Impl() : value(42) {} // 初始化 value
};

MyClass::MyClass() : impl(std::make_unique<Impl>()) {
    // 构造函数实现
}

MyClass::~MyClass() {
    // unique_ptr 会自动释放 Impl 的内存
}

void MyClass::display() {
    std::cout << "Value: " << impl->value << std::endl;
}
主程序 (main.cpp)
#include "example.h"

int main() {
    MyClass myObject;
    myObject.display(); // 输出 Value: 42
    return 0;
}
```

##### 说明

头文件 (example.h):

定义了 MyClass 类，包含一个 `std::unique_ptr<Impl>` 成员指针，用于管理 Impl 结构的生命周期。
Impl 是一个私有结构，使用前向声明，确保封装。

源文件 (example.cpp):

实现了 MyClass 的构造函数，使用 std::make_unique 创建 Impl 的实例。
析构函数不需要显式释放 Impl，因为 std::unique_ptr 会自动处理内存。
主程序 (main.cpp):

创建 MyClass 的实例，并调用 display 方法。
这样，std::unique_ptr 可以有效地管理内存，避免内存泄漏和悬挂指针的问题。

#### 如果动态指针中的函数需要一些入参

```c++
// 头文件 (example.h)
#ifndef EXAMPLE_H
#define EXAMPLE_H

#include <memory>
#include <iostream>

class MyClass {
public:
    MyClass(int initialValue);
    ~MyClass();

    void display() const;
    void setValue(int newValue);

private:
    struct Impl;
    std::unique_ptr<Impl> impl;
};

#endif // EXAMPLE_H

// 源文件 (example.cpp)
#include "example.h"

struct MyClass::Impl {
    int value;
    Impl(int initialValue) : value(initialValue) {} // 初始化 value
};

MyClass::MyClass(int initialValue) 
    : impl(std::make_unique<Impl>(initialValue)) {
    // 构造函数实现
}

MyClass::~MyClass() {
    // unique_ptr 会自动释放 Impl 的内存
}

void MyClass::display() const {
    std::cout << "Value: " << impl->value << std::endl;
}

void MyClass::setValue(int newValue) {
    impl->value = newValue;
}

// 主程序 (main.cpp)
#include "example.h"

int main() {
    MyClass myObject(42); // 传递初始值
    myObject.display();    // 输出 Value: 42
    
    myObject.setValue(100); // 设置新值
    myObject.display();      // 输出 Value: 100
    
    return 0;
}

```

##### 说明

1. **头文件 (`example.h`)**:
   - `MyClass` 的构造函数现在接收一个 `int` 类型的参数 `initialValue`，用于初始化 `Impl` 中的 `value`。
   - 添加了 `setValue` 方法，允许更新 `value` 的值。

2. **源文件 (`example.cpp`)**:
   - 在 `Impl` 的构造函数中使用传入的 `initialValue` 进行初始化。
   - `display` 和 `setValue` 方法用于显示和设置 `value`。

3. **主程序 (`main.cpp`)**:
   - 创建 `MyClass` 的实例时传入初始值 `42`。
   - 通过 `setValue` 方法更新值，并显示结果。

通过这种方式，`std::unique_ptr` 仍然负责管理动态对象的生命周期，而构造函数和其他成员函数可以接收参数以初始化或修改对象的状态。
