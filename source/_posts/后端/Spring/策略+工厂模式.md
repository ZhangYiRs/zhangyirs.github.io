---
title: 策略+工厂模式
date: 2021-08-02 11:33:04
tags: [Java,Spring,设计模式]
categories: 设计模式
---

## 实际应用场景

工厂模式通过springboot实现，我们只需要实现不同的策略通过自动注入来实现策略模式，再通过一个枚举类将类名转换为数字方便与前端交互。

```java
// 通过自动注入，自动将所有的HangEventStrategy实现类注入到map中，
// key是类名，value是HangEventStrategy具体的实现类
private final Map<String, HangEventStrategy> hangEventMap;
```

{% asset_img map自动注入.png map自动注入%}

```java
public enum HangEventEnum {
    // 好友事件
    FRIEND(0, "hangEventFriendStrategy"),
    // 答题事件
    QUESTION(1, "hangEventQuestionStrategy"),
    // 道具获取事件
    ITEM(2, "hangEventItemStrategy"),
    // 自定义事件
    CUSTOM(3, "hangEventCustomStrategy"),
    // 回家事件
    HOME(4, "hangEventHomeStrategy");

    private final int value;
    private final String hangEventStrategy;

    HangEventEnum(int value, String hangEventStrategy) {
        this.value = value;
        this.hangEventStrategy = hangEventStrategy;
    }

    public int getValue() {
        return value;
    }

    public static String valueOf(int value) {
        for (HangEventEnum hangEventEnum : HangEventEnum.values()) {
            if (hangEventEnum.value == value) {
                return hangEventEnum.hangEventStrategy;
            }
        }
        return null;
    }
}
```

所有策略所需实现的接口

```java
public interface HangEventStrategy {

    /**
     * 获取事件信息
     *
     * @param type 返回结果
     * @param eventDTO       所需参数
     */
    void info(HangEventGetVO.Type type, EventDTO eventDTO);

    /**
     * 处理事件
     *
     * @param po 处理入参
     * @return 处理结果
     */
    HangEventHandleVO handle(HangEventHandlePO po) throws IOException;
}

```

具体策略，可以实现多个接口，多个接口都可以通过map的自动注入导入其他实体类中当作字段使用

```java
@Service
public class HangEventCustomStrategy implements HangEventStrategy,test {

    private final HangEventCustomMapper hangEventCustomMapper;
    private final HangEventRecordMapper hangEventRecordMapper;

    @Autowired
    public HangEventCustomStrategy(HangEventCustomMapper hangEventCustomMapper,
                                   HangEventRecordMapper hangEventRecordMapper) {
        this.hangEventCustomMapper = hangEventCustomMapper;
        this.hangEventRecordMapper = hangEventRecordMapper;
    }

    @Override
    public void info(HangEventGetVO.Type type, EventDTO eventDTO) {
        HangEventGetVO.Custom custom = new HangEventGetVO.Custom();
        HangEventCustom hangEventCustom = hangEventCustomMapper.selectByPrimaryKey(eventDTO.getFkId());
        if (hangEventCustom != null) {
            custom.setRecordId(eventDTO.getHangEventRecordId()).setTitle(hangEventCustom.getTitle()).setContent(hangEventCustom.getContent()).setImg(hangEventCustom.getImg());
        }
        type.setCustom(custom);
    }

    @Override
    public HangEventHandleVO handle(HangEventHandlePO po) {
        hangEventRecordMapper.updateByPrimaryKeySelective(new HangEventRecord().setId(po.getRecordId()).setHandle(1));
        return new HangEventHandleVO().setItemList(new ArrayList<>());
    }
}

```
