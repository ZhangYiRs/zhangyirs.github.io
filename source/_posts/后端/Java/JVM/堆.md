---
title: 堆
p: 后端/Java/JVM/堆
date: 2020-08-27 20:35:36
tags: [Java,JVM]
categories: [Java,JVM]
---
## 概述

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。
- 堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定，堆可以处于物理撒花姑娘不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）

## 内存细分

{% asset_img 堆空间.png 堆空间%}

新生区+养老区+元空间

- Young Generation Space 新生区 Young/New
  - 又被划分为Eden区和Survivor区
- Tenure generation space 养老区 Old/Tenure
- Meta Space 元空间 Meta

{% asset_img 差异.png 差异%}

## 堆空间的大小设置和查看

- Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项"-Xmx"和"-Xms"来进行设置。
  - "-Xms"用于表示堆区的起始内存，等价于-XX:InitialHeapSize
  - "-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize
- 一旦堆区中的内存大小超过"-Xmx"所指定的最大内存时，将会跑出OutOfMemoryError异常
- 通常会将-Xms和-Xmx两个参数配置相同的，**其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。**
- 默认情况下，初始内存大小: 物理电脑内存大小/64
             最大内存大小: 物理电脑内存大小/4

```java
-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小
    -X 是jvm的运行参数
    ms 是memory start
-Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小
```

- 手动设置：-Xms600m -Xmx600m
  开发中建议将初始堆内存和最大的堆内存设置成相同的值
- 查看设置的参数：方式一：jps / jstart -gc 进程id
                 方式二：-XX:+PrintGCDetails

```java
-Xms: 575 M
-Xmx: 575 M
系统内存大小为：35.9375 G
系统内存大小为：2.24609375 G
Heap
 PSYoungGen      total 179200K, used 9216K [0x00000000f3800000, 0x0000000100000000, 0x0000000100000000)
  eden space 153600K, 6% used [0x00000000f3800000,0x00000000f41001a0,0x00000000fce00000)
  from space 25600K, 0% used [0x00000000fe700000,0x00000000fe700000,0x0000000100000000)
  to   space 25600K, 0% used [0x00000000fce00000,0x00000000fce00000,0x00000000fe700000)
 ParOldGen       total 409600K, used 0K [0x00000000da800000, 0x00000000f3800000, 0x00000000f3800000)
  object space 409600K, 0% used [0x00000000da800000,0x00000000da800000,0x00000000f3800000)
 Metaspace       used 3176K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 345K, capacity 388K, committed 512K, reserved 1048576K
```

179200K = 153600 + 25600
jvm默认from和to只有一个有数据
所以575 = （153600 + 25600 + 409600）/1024

## OutOfMemory举例（OOM内存溢出）

```java
public class OutOfMemory {
    public static void main(String[] args) {
        ArrayList<Pic> list = new ArrayList<>();
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            list.add(new Pic(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Pic{
    private byte[] pix;

    public Pic(int length) {
        pix = new byte[length];
    }
}

```

Error occurred during initialization of VM
Too small initial heap

## 年轻代与老年代

- 存储在JVM中的Java对象可以被划分为两类“
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期却非常长，在某些极端请胯下还能与JVM的生命周期保持一致
- Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）
- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫作from区、to区）

下面参数开发中一般不会调整

- 配置新生代与老年代在对结构的占比
  - 默认-XX:NewRatio = 2, 表示新生代占1，老年代占2，新生代占整个堆的1/3
  - 可以修改-XX:NewRatio = 4 ,表示新生代占1，老年代占4，新生代占整个堆的1/5

- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1
- 当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio = 8
- 几乎所有的Java对象都是在Eden区被new出来的

## 对象分配过程

一般对象会出生在Eden区，经过一段时间Eden满了还在使用会转移到to区，在form和to之间转移一段时间后，迭代15次，转移到老年代。

1. 针对幸存者s0、s1区的总结：复制之后又交换，谁空谁是to
2. 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集。

{% asset_img 对象分配.png 对象分配.png%}

## Minor GC、Major GC与Full GC

> JVM在进行GC时,并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。

针对HotSpot Vm的实现，他里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
  - 新生代收集（Minor GC/Young GC) : 只是新生代的垃圾收集。
  - 老年代收集（Major GC/Old GC) : 只是老年代的垃圾收集，OOM在这个时候出现。
    - 目前，只有CMS GC会有单独收集老年代的行为。
    - 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
    - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。
      - 目前，只有G1 GC会有这种行为
- 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。

### 分代式GC策略的出发条件

#### 年轻代GC（Minor GC）触发机制

- 当年轻代空间不足时，就会出发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）
- 因为Java对象**大多都具备朝生夕灭**的特性，所以Minor GC 非常频繁，一般回收速度也比较快。
- Minor GC 会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。

#### 老年代GC（Major GC/Full GC)出发机制

- 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。
- 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。
  - 也就是在老年代空间不足时，会先尝试出发Minor GC。如果之后空间还不足，则出发Major GC
- Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长
- 如果Major GC后，内存还不足，就报OOM了。

> STW: Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。GC时的Stop the World(STW)是大家最大的敌人。但可能很多人还不清楚，除了GC，JVM下还会发生停顿现象。

#### Full GC出发机制

1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

说明：**full gc是开发或调优中尽量要避免的。这样暂时时间会短一些**

### 堆空间分代思想

**为什么需要把Java堆分代？不分代就不能正常工作了吗？**

- 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。
  - 新生代：有Eden、两块大小相同的Survivor（又称为from/to,s0/s1）构成，to总为空。
  - 老年代：存放新生代中经历多次GC仍然存活的对象。

> 其实不分代完全可以，分代的唯一理由就是**优化GC性能**。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，吧新创建的对象放到某一地方，当GC的时候先把这块存储朝生夕死对象的区域进行回收，这样就会腾出很大的空间出来。

## 内存分配策略（或对象提升（Promotion）规则）

针对不同年龄段的对象分配原则如下所示：

- 优先分配代Eden
- 大对象直接分配到老年代
  - 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  - 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
- 空间分配担保
  - -XX:HandlePromotionFailure

## 堆时分配对象存储的唯一选择么

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的尝试。但是，有一种特殊情况，那就是**如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。**这样就无需再堆上分配内存，也无须进行垃圾回收了。这也是最常见的对外存储技术。

### 逃逸分析概述

如何将堆上的对象分配到栈，需要使用逃逸分析手段，如果变量没有发生逃逸，则会在栈上存储。
逃逸分析的基本行为就是分析对象动态作用域：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
- 当一个对象在方法中被顶一会，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

```java
public void my_method(){
  V v = new V();
  // use v
  // ...
  v = null;
}
```

```java
public static StringBuffer createStringBuffer(String s1,String s2){
  StringBuffer sb = new StringBuffer();
  sb.append(s1);
  sb.append(s2);
  return sb;
}
// 上述代码如果想要StringBuffer sb不逃出方法，可以这样写:
public static String createStringBuffer(String s1,String s2){
  StringBuffer sb = new StringBuffer();
  sb.append(s1);
  sb.append(s2);
  return sb.toString();
}
```

```java
package JVM.chapter08;

/**
* @Description ：如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。
* @Date   2020/11/8 20:50
* @Param
* @Return
*/
public class EscapeAnalysis {
    public EscapeAnalysis obj;

    /*
     * @Description: 方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance(){
        return obj == null ? new EscapeAnalysis() : obj;
    }
    /*
     * @Description: 为成员属性赋值，发生逃逸
     */
    public void setObj(){
        this.obj = new EscapeAnalysis();
    }
    // 思考：如果当前的obj引用声明为static的？仍然会发生逃逸。
    /*
     * @Description:对象的作用域尽在放弃方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis(){
        EscapeAnalysis e = new EscapeAnalysis();
    }
    /*
     * @Description:引用成员变量的值，发生逃逸
     */
    public void useEscapeAnalysis1(){
        EscapeAnalysis e = getInstance();
    }

}
```

### 参数设置

如果使用的是较早的版本，开发人员则可以通过：

- 选择“-XX: +DoEscapeAnalysis”显式开启逃逸分析
- 通过选项“-XX: +PrintEscapeAnalysis”查看逃逸分析的筛选结果。

### 结论

> 开发中能不使用局部变量的，就不要使用在方法外定义。

## 逃逸分析：代码优化

使用逃逸分析，编译器可以对代码做出如下优化：
一、栈上分配。将对分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
二、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

## 为对象分配内存：TLAB

> 为什么有TLAB（Thread Local Allocation Buffer）？

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

> 什么是TLAB？

- 从内测模型而不是垃圾收集的角度，对Eden继续划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为**快速分配策略**。

- 尽管不是所有对象实例都能够在TLAB中成功分配内UC你，但JVM确实是将TLAB作为内存分配的首选。
- 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间
- 默认情况下，TLAB空间的内存非常小，**仅占有整个Eden空间的1%,当然我们可以通过选项“-XX：TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。
- 一旦对象在TLAB空间分配内存失败时，JVM就会城市通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

## 堆空间参数设置小结

```java
-XX:+PrintFlagsInitial : 查看所有的参数的默认初始值
-XX:+PrintFalgsFinal : 查看所有的参数的最终值（可能会存在修改，不再是初始值）
    具体查看某个参数的指令: jps: 查看当前运行中的进程
                          jinfo: -flag SurvivorRatio 进程io
-Xms: 初始堆空间内存（默认为物理内存的1/64）
-Xmx: 最大堆空间内存（默认为物理内存的1/4）
-Xmn: 设置新生代的大小（初始值及最大值）
-XX:NewRatio: 配置新生代与老年代在堆结构的占比
-XX:SurvivorRatio: 设置新生代中Eden和So/S1空间的比例
-XX:MaxTenuringThreshold: 设置新生代垃圾的最大年龄
-XX:+PrintGCDetails: 输出详细的GC处理日志
打印gc简要信息：1. -XX:+PrintGC 2. -verbose:gc
-XX:HandlePromotionFailure: 是否设置空间分配担保（jdk7之后默认为true）
    空间分配担保：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC
```
