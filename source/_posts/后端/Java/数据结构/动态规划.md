---
title: 动态规划
p: 后端/Java/数据结构/动态规划
date: 2020-02-22 16:11:38
tags:  [数据结构,动态规划]
categories: [数据结构,动态规划]
---
## 动态规划

{% asset_img 动态规划.png 动态规划 %}

遇到动态规划问题，首先思考将大问题拆解成一个个小问题，
写出解题方程，然后写出状态方程
先用递归的思路解决问题，
然后用记忆法进行优化，然后使用动态规划。

## 01背包问题

有一个背包，它的容量为C（Capacity），现在有n中不同的物品，编号为0...n-1，其中每一件物品的重量为w(i),
价值为v(i).问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大

 暴力解法：每一件物品都可以放进背包，也可以不放进背包。
 时间复杂度    O((2^n)*n)

 F(n,C)考虑将n个物品放进容量为C的背包，使得价值最大
 F(i,c) = F(i-1,c)
        = v(i) + F(i-1,c - w(i))
 F(i,c) = max(F(i-1,c), v(i) + F(i-1,c-w(i))

{% asset_img 01背包问题.png 01背包问题 %}

```java
/**
 * @Description TODO 0-1背包问题
 * 有一个背包，它的容量为C（Capacity），现在有n中不同的物品，编号为0...n-1，其中每一件物品的重量为w(i),
 * 价值为v(i).问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大
 *
 * 暴力解法：每一件物品都可以放进背包，也可以不放进背包。
 * 时间复杂度    O((2^n)*n)
 *
 * F(n,C)考虑将n个物品放进容量为C的背包，使得价值最大
 * F(i,c) = F(i-1,c)
 *        = v(i) + F(i-1,c - w(i))
 * F(i,c) = max(F(i-1,c), v(i) + F(i-1,c-w(i))
 * @Author Matthew
 * @Date 2020/2/20 20:26
 * @Version 1.0
 */

public class Knapsack01 {
    // 由于背包有2个因素限制，所以记忆空间需要二维数组
    int[][] memo;

    public int knapsack01(int[] w, int[] v, int C) {
        int n = w.length;
        memo = new int[n][C + 1];
        Tool.Array2Fill(memo, -1);
        return bestValue(w, v, n - 1, C);
    }
    /**
    * @Description ：用[0...index]的物品，填充容积为c的背包的最大价值
    * @Date   2020/2/20 20:43
    * @Param  w[]:每一件物品的重量  v[]：每一件物品的价值
     *          index：第index件物品 c：容量
    * @Return 当前物品能存放物品的最大价值
    */
    private int bestValue(int[] w, int[] v, int index, int c) {
        if (index < 0 || c <= 0) {
            return 0;
        }
        if (memo[index][c] == -1) {
            int res = bestValue(w, v, index - 1, c);
            if (c >= w[index]) {
                res = Math.max(res, v[index] + bestValue(w, v, index - 1, c - w[index]));
            }
            memo[index][c] = res;
        }
        return memo[index][c];
    }


    public int knapsack01_2(int[] w, int[] v, int C) {
        assert (w.length == v.length);
        int n = w.length;
        if (n == 0) {
            return 0;
        }
//        将记忆空间按照每一行增加一个物品，每一列增加一个容量
        // 优化空间复杂度，只用2行
        int[][] memo = new int[2][C + 1];
        Tool.Array2Fill(memo, -1);
//        先计算第一行的最大价值
        for (int i = 0; i <= C; i++) {
            memo[0][i] = i >= w[0] ? v[0] : 0;
        }
//        之后的每一行的每一列按照以下逻辑计算
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= C; j++) {
//                每一列的下一行大于等于上一行
                memo[i % 2][j] = memo[(i - 1) % 2][j];
//                如果容量大于这一行的物品的重量，就进行以下计算
                if (j >= w[i]) {
                    //  Math.max(这一列上一行的价值（没有这个物品的价值），这个物品的价值+剩余容量的价值）
                    memo[i % 2][j] = Math.max(memo[i % 2][j], v[i] + memo[(i - 1) % 2][j - w[i]]);
                }
            }
        }
        return memo[(n - 1) % 2][C];
    }

    public int knapsack01_3(int[] w, int[] v, int C) {
        assert (w.length == v.length);
        int n = w.length;
        if (n == 0) {
            return 0;
        }
        // 再次优化只用1行
        int[] memo = new int[C + 1];
        for (int i = 0; i <= C; i++) {
            memo[i] = i >= w[0] ? v[0] : 0;
        }
        for (int i = 1; i < n; i++) {
            for (int j = C; j >= C - w[i]; j--) {
                memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);
            }
        }
        return memo[C];
    }

}


public class Tool {
    public static void Array2Fill(int[][] n, int val) {
        for (int i = 0; i < n.length; i++) {
            for (int j = 0; j < n[0].length; j++) {
                n[i][j] = val;
            }
        }
    }
}

```
