---
title: 动态规划
p: 后端/Java/数据结构/动态规划
date: 2020-02-22 16:11:38
tags:  [数据结构,动态规划]
categories: [数据结构,动态规划]
---
## 动态规划

> Dynamic Programming, DP,动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
  能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。

### 最优子结构

具有最优子结构也可能是适合用贪心的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

    证明问题最优解的第一个组成部分是做出一个选择；
    对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
    给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
    证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

    原问题的最优解中涉及多少个子问题；
    确定最优解使用哪些子问题时，需要考察多少种选择。

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

### 无后效性

已经求解的子问题，不会再受到后续决策的影响。

### 子问题重叠

如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。
基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

    将原问题划分为若干 阶段，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 状态）；
    寻找每一个状态的可能 决策，或者说是各状态间的相互转移方式（用数学的语言描述就是 状态转移方程）。
    按顺序求解每一个阶段的问题。


{% asset_img 动态规划.png 动态规划 %}

遇到动态规划问题，首先思考将大问题拆解成一个个小问题，
写出解题方程，然后写出状态方程
先用递归的思路解决问题，
然后用记忆法进行优化，然后使用动态规划。

## 最长公共子序列

给定一个长度为n的序列A和一个m长度为B的序列 （n,m <= 5000 ），求出一个最长的序列，使得该序列既是A的子序列，也是B的子序列。

```c++
int a[MAXN], b[MAXM], f[MAXN][MAXM];

int dp() {
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      if (a[i] == b[j])
        f[i][j] = f[i - 1][j - 1] + 1;
      else
        f[i][j] = std::max(f[i - 1][j], f[i][j - 1]);
  return f[n][m];
}
```

## 01背包问题

有一个背包，它的容量为C（Capacity），现在有n中不同的物品，编号为0...n-1，其中每一件物品的重量为w(i),
价值为v(i).问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大

 暴力解法：每一件物品都可以放进背包，也可以不放进背包。
 时间复杂度    O((2^n)*n)

 F(n,C)考虑将n个物品放进容量为C的背包，使得价值最大
 F(i,c) = F(i-1,c)
        = v(i) + F(i-1,c - w(i))
 F(i,c) = max(F(i-1,c), v(i) + F(i-1,c-w(i))

{% asset_img 01背包问题.png 01背包问题 %}

```java
/**
 * @Description TODO 0-1背包问题
 * 有一个背包，它的容量为C（Capacity），现在有n中不同的物品，编号为0...n-1，其中每一件物品的重量为w(i),
 * 价值为v(i).问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大
 *
 * 暴力解法：每一件物品都可以放进背包，也可以不放进背包。
 * 时间复杂度    O((2^n)*n)
 *
 * F(n,C)考虑将n个物品放进容量为C的背包，使得价值最大
 * F(i,c) = F(i-1,c)
 *        = v(i) + F(i-1,c - w(i))
 * F(i,c) = max(F(i-1,c), v(i) + F(i-1,c-w(i))
 * @Author Matthew
 * @Date 2020/2/20 20:26
 * @Version 1.0
 */

public class Knapsack01 {
    // 由于背包有2个因素限制，所以记忆空间需要二维数组
    int[][] memo;

    public int knapsack01(int[] w, int[] v, int C) {
        int n = w.length;
        memo = new int[n][C + 1];
        Tool.Array2Fill(memo, -1);
        return bestValue(w, v, n - 1, C);
    }
    /**
    * @Description ：用[0...index]的物品，填充容积为c的背包的最大价值
    * @Date   2020/2/20 20:43
    * @Param  w[]:每一件物品的重量  v[]：每一件物品的价值
     *          index：第index件物品 c：容量
    * @Return 当前物品能存放物品的最大价值
    */
    private int bestValue(int[] w, int[] v, int index, int c) {
        if (index < 0 || c <= 0) {
            return 0;
        }
        if (memo[index][c] == -1) {
            int res = bestValue(w, v, index - 1, c);
            if (c >= w[index]) {
                res = Math.max(res, v[index] + bestValue(w, v, index - 1, c - w[index]));
            }
            memo[index][c] = res;
        }
        return memo[index][c];
    }


    public int knapsack01_2(int[] w, int[] v, int C) {
        assert (w.length == v.length);
        int n = w.length;
        if (n == 0) {
            return 0;
        }
//        将记忆空间按照每一行增加一个物品，每一列增加一个容量
        // 优化空间复杂度，只用2行
        int[][] memo = new int[2][C + 1];
        Tool.Array2Fill(memo, -1);
//        先计算第一行的最大价值
        for (int i = 0; i <= C; i++) {
            memo[0][i] = i >= w[0] ? v[0] : 0;
        }
//        之后的每一行的每一列按照以下逻辑计算
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= C; j++) {
//                每一列的下一行大于等于上一行
                memo[i % 2][j] = memo[(i - 1) % 2][j];
//                如果容量大于这一行的物品的重量，就进行以下计算
                if (j >= w[i]) {
                    //  Math.max(这一列上一行的价值（没有这个物品的价值），这个物品的价值+剩余容量的价值）
                    memo[i % 2][j] = Math.max(memo[i % 2][j], v[i] + memo[(i - 1) % 2][j - w[i]]);
                }
            }
        }
        return memo[(n - 1) % 2][C];
    }

    public int knapsack01_3(int[] w, int[] v, int C) {
        assert (w.length == v.length);
        int n = w.length;
        if (n == 0) {
            return 0;
        }
        // 再次优化只用1行
        int[] memo = new int[C + 1];
        for (int i = 0; i <= C; i++) {
            memo[i] = i >= w[0] ? v[0] : 0;
        }
        for (int i = 1; i < n; i++) {
            for (int j = C; j >= C - w[i]; j--) {
                memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);
            }
        }
        return memo[C];
    }

}


public class Tool {
    public static void Array2Fill(int[][] n, int val) {
        for (int i = 0; i < n.length; i++) {
            for (int j = 0; j < n[0].length; j++) {
                n[i][j] = val;
            }
        }
    }
}

```

## 其他练习题

70 爬楼梯
198 打劫
64 最小路径和


最长递增序列[1,5,2,4,3]
