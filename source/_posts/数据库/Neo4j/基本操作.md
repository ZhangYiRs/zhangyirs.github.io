---
title: 基本操作
p: 数据库/Neo4j/基本操作
date: 2021-02-21 23:00:37
tags: Neo4j
categories: Neo4j
---
## 概念

Neo4j是一个世界领先的开源图形数据库。 它是由Neo技术使用Java语言完全开发的。
简单地说，我们可以说图数据库主要用于存储更多的连接数据。
如果我们使用 RDBMS 数据库来存储更多连接的数据，那么它们不能提供用于遍历大量数据的适当性能。 在这些情况下，Graph Database 提高了应用程序性能。
如今，大多数社交网络应用程序（如Facebook，Google +，LinkedIn，Twitter，Yammer 等）和视频托管应用程序（如 Google YouTube，Flickr，Yahoo Video等）都在使用更多连接的数据。

## 特点

- SQL就像简单的查询语言Neo4j CQL
- 它遵循属性图数据模型
- 它通过使用Apache Lucence支持索引
- 它支持UNIQUE约束
- 它包含一个用于执行CQL命令的UI：Neo4j数据浏览器
- 它支持完整的ACID（原子性，一致性，隔离性和持久性）规则
- 它采用原生图形库与本地GPE（图形处理引擎）
- 它支持查询的数据导出到JSON和XLS格式
- 它提供了REST API，可以被任何编程语言（如Java，Spring，Scala等）访问
- 它提供了可以通过任何UI MVC框架（如Node JS）访问的Java脚本
- 它支持两种Java API：Cypher API和Native Java API来开发Java应用程序

## 优势

- 它很容易表示连接的数据
- 检索/遍历/导航更多的连接数据是非常容易和快速的
- 它非常容易地表示半结构化数据
- Neo4j CQL查询语言命令是人性化的可读格式，非常容易学习
- 使用简单而强大的数据模型
- 它不需要复杂的连接来检索连接的/相关的数据，因为它很容易检索它的相邻节点或关系细节没有连接或索引 

## 数据模型

> Neo4j图数据库遵循属性图模型来存储和管理其数据。

图形数据库数据模型的主要构建块是: 

1. 节点
2. 关系
3. 属性

## 基本操作

> neo4j 查询时带箭头代表单向关系，不带箭头代表双向关系

```java
package com.mega.werewolf.cloud.jp.contact.neo4j;

import lombok.Data;
import lombok.experimental.Accessors;
import org.springframework.data.neo4j.core.schema.Id;
import org.springframework.data.neo4j.core.schema.Node;
import org.springframework.data.neo4j.core.schema.Relationship;

import java.time.LocalDateTime;
import java.util.List;

@Data
@Node
@Accessors(chain = true)
public class Person {
    @Id
    private Integer userId;

    // 用户名称
    private String nickName;

    // 用户登录时间
    private LocalDateTime loginTime;

    @Relationship(type = "Friend", direction = Relationship.Direction.OUTGOING)
    private List<Friend> friendList;

}

```

```java
package com.mega.werewolf.cloud.jp.contact.neo4j;

import lombok.Data;
import lombok.experimental.Accessors;
import org.springframework.data.neo4j.core.schema.RelationshipProperties;
import org.springframework.data.neo4j.core.schema.TargetNode;
import org.springframework.data.redis.core.index.Indexed;

import java.time.LocalDateTime;

@Data
@RelationshipProperties
@Accessors(chain = true)
public class Friend {

    // 好友关系：0: 普通关系，1: 兄弟，2:闺蜜，999: CP
    private Integer type = 0;
    // 备注
    private String remark = "";
    // 亲密值
    private Integer intimacy = 0;
    // 亲密等级
    private Integer intimacyLevel = 0;
    // 关系申请状态，4：未处理，1：同意，2：拒绝，3：超时
    private Integer letterState = 0;
    // 申请关系：1: 兄弟，2:闺蜜，999: CP
    private Integer letterType = 0;
    // 关系申请ID tfriendmessage表id
    private Integer letterId = 0;
    // 创建时间
    private LocalDateTime createTime = LocalDateTime.now();
    // 亲密关系创建时间
    private Long intimacyCreateTime;
    // 亲密度修改时间
    private Long intimacyUpdateTime;
    @TargetNode
    private Person person;
}
```

## 查询

```java
   /** 
    * 查找好友的所有信息
    */
@Query("MATCH (u:Person)-[a:Friend]-(f:Person) " +
        "WHERE u.userId = $userId AND f.userId = $friendId " +
        "RETURN u,collect(a),collect(f)")
Person findByUserIdAndFriendId(Integer userId, Integer friendId);
```

## 更新

```java
@Query("MATCH (u:Person)-[a:Friend]->(f:Person) " +
        "WHERE u.userId = $userId AND f.userId = $friendId " +
        "SET a.remark = $name")
void updateRemark(Integer userId, Integer friendId, String name);
```

## 删除

```java
/**
* 删除双向好友关系
*
* @param userId   用户Id
* @param friendId 好友Id
*/
@Query("MATCH (u:Person)-[a:Friend]-(f:Person) " +
    "WHERE u.userId = $userId AND f.userId = $friendId " +
    "DELETE a")
void deleteFriend(Integer userId, Integer friendId);
```

## 索引

```cql
创建索引
CREATE INDEX ON :Customer (name)

删除索引
DROP INDEX ON :<label_name> (<property_name>)

设置唯一索引
CREATE CONSTRAINT ON (cc:CreditCard)
ASSERT cc.number IS UNIQUE
```
