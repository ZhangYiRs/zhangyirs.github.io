---
title: 复杂查询
p: 数据库/Mongo/复杂查询
date: 2021-02-21 23:01:05
tags: Mongo
categories: Mongo
---

当一个集合中的属性是数组，并且你需要按照数组中的对象字段进行排序和limit。
这样你需要按照该数组进行聚合，unwind，这样每一个数组中的对象都对应一整条记录。

**需要注意的是聚合的参数顺序影响最终的结果**

```java
Sort.Order orderId = new Sort.Order(Sort.Direction.DESC, "commentList.id");
Sort sort = Sort.by(orderId);
Criteria lt = Criteria.where("commentList.createTime").gt(tuserHang.getWatchTime()).and("commentList" +
                            "._id").lt(po.getId()).orOperator(Criteria.where("commentList.userId").is(po.getUserId()),
                            Criteria.where("commentList.replayUserId").is(po.getUserId()));
List<FriendMomentPage> commentList = mongoTemplate.aggregate(
                Aggregation.newAggregation(Aggregation.unwind("commentList"), Aggregation.match(lt),
                        Aggregation.sort(sort), Aggregation.limit(PAGE_SIZE)), FriendMoment.class,
                FriendMomentPage.class).getMappedResults();
```

原先的实体类

```java
package com.mega.werewolf.cloud.jp.contact.mongo;

import lombok.Data;
import lombok.experimental.Accessors;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.FieldType;
import org.springframework.data.mongodb.core.mapping.MongoId;

import java.util.List;

@Document(collection = "friend_moment")
@Data
@Accessors(chain = true)
public class FriendMoment {
    /**
     * ID
     */
    @MongoId(FieldType.OBJECT_ID)
    private String id;

    /**
     * 发朋友圈的用户信息
     */
    @Indexed
    private Integer userId;

    /**
     * 朋友圈文案
     */
    private String content;

    /**
     * 朋友圈图片
     */
    private String img;

    /**
     * 图片标签
     */
    private String tag;

    /**
     * 朋友圈事件类型：0：获取SSR物品，1：获得MVP，2：获得成就，3：获得称号，4：修改心情，5：在攻略论坛中进行评论
     */
    private Integer type;

    /**
     * 游戏Id
     */
    private Integer gameId;

    /**
     * 游戏阵营
     */
    private Integer camp;


    /**
     * 链接
     */
    private String link;

    /**
     * 创建时间
     */
    @Indexed
    private Long createTime;

    /**
     * 评论列表
     */
    @Indexed
    private List<FriendMomentComment> commentList;

    @Data
    @Accessors(chain = true)
    public static class FriendMomentComment {
        /**
         * ID
         */
        @Indexed(unique = true)
        private Long id;

        /**
         * 评论用户ID
         */
        @Indexed
        private Integer userId;

        /**
         * 回复用户ID
         */
        @Indexed
        private Integer replayUserId;

        /**
         * 评论时间
         */
        @Indexed
        private Long createTime;

        /**
         * 评论内容
         */
        private String content;

        /**
         * 是否删除：0：没删除，1：删除
         */
        private Integer delsign;
    }
}

```

聚合后的实体类

```java
package com.mega.werewolf.cloud.jp.contact.mongo;

import lombok.Data;
import lombok.experimental.Accessors;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.FieldType;
import org.springframework.data.mongodb.core.mapping.MongoId;

import java.util.List;

@Document(collection = "friend_moment")
@Data
@Accessors(chain = true)
public class FriendMomentPage {
    /**
     * ID
     */
    @MongoId(FieldType.OBJECT_ID)
    private String id;

    /**
     * 发朋友圈的用户信息
     */
    @Indexed
    private Integer userId;

    /**
     * 朋友圈文案
     */
    private String content;

    /**
     * 朋友圈图片
     */
    private String img;

    /**
     * 图片标签
     */
    private String tag;

    /**
     * 朋友圈事件类型：0：普通朋友圈，无点击事件，1：获取SSR物品，2：获得MVP，3：在攻略论坛中进行评论
     */
    private Integer type;

    /**
     * 游戏Id
     */
    private Integer gameId;

    /**
     * 链接
     */
    private String link;

    /**
     * 创建时间
     */
    @Indexed
    private Long createTime;

    /**
     * 评论列表
     */
    private FriendMoment.FriendMomentComment commentList;


}
```

## MONGO在PHP中的操作

> 在php中要注意类型转换问题，并且聚合后取出结果要toArray

```php
$provider = new DBProvider();
$mongo = $provider->getMongoClient();
$collection = $mongo->selectCollection(\Configs::MONGO_DATABASE_WEREWOLFJP, \Configs::MONGO_DB_WEREWOLFJP_COLLECTIONS_FRIEND_MOMENT);
if ($watchTime != null && $watchTime['watch_time'] != null) {
    $result = $collection->aggregate([
        ['$unwind'=>'$commentList'],
        ['$match'=>['$and' => [
                ["commentList.createTime" => ['$gt' => $watchTime['watch_time']]],
                ["commentList.userId" => ['$ne' => (int)$userNo]],
                ['$or'=>[["userId" => (int)$userNo],["commentList.replayUserId" => (int)$userNo]]]
            ]]
        ]
    ])->toArray();
} else {
    $result = $collection->aggregate([
        ['$unwind'=>'$commentList'],
        ['$match'=>['$and' => [
            ['$or'=>[["userId" => (int)$userNo],["commentList.replayUserId" => (int)$userNo]]],
            ['commentList._id' => ['$exists' => 'true']],
            ["commentList.userId" => ['$ne' => (int)$userNo]]
            ]]
        ]
    ])->toArray();
}
foreach ($result AS $item){
    $this->logger->Debug($item['type']);
}
if (count($result) > 0) {
    return 1;
} else {
    return 0;
}
```
